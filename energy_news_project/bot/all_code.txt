===== C:\Users\SK-GROUP\PycharmProjects\PythonProject\energy_news_project\bot\bot_runner.py =====
# bot/bot_runner.py

import asyncio
import logging

from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
from bot.db import NewsDB
from bot.telegram_bot import send_to_moderation, make_news_id, PUBLISH_CHANNEL
from bot.telegram_handlers import button_handler, edit_text_handler, skip_edit_handler
from bot.cli import load_and_send_news
from telegram.constants import ChatType

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

TOKEN = "8217915867:AAFLPnQmnxhHmjloF4Ct3HhR9jjRjVYV6C8"

# Инициализация базы
db = NewsDB()


# --- Команды ---
async def start(update, context):
    await update.message.reply_text("Бот запущен.")


# Добавьте эту функцию в bot_runner.py
async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Логируем ошибки, вызванные обновлениями."""
    logger.error("Exception while handling an update:", exc_info=context.error)


async def test_publish_command(update, context):
    try:
        await context.bot.send_message(chat_id=PUBLISH_CHANNEL, text="🔔 Тестовая публикация")
        await update.message.reply_text("Отправлено (если бот имеет доступ к каналу).")
    except Exception as e:
        await update.message.reply_text(f"⚠️ Ошибка при публикации: {e}")


# --- Post init ---
async def post_init(app):
    try:
        await app.bot.delete_webhook(drop_pending_updates=True)
    except Exception as e:
        logger.warning(f"Не удалось удалить webhook: {e}")

    # Запуск консольного меню в отдельной таске
    asyncio.create_task(load_and_send_news(db, app.bot))


# --- Запуск бота ---
def run_bot():
    application = Application.builder().token(TOKEN).post_init(post_init).build()

    # --- Хэндлеры ---
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("testpublish", test_publish_command))
    application.add_handler(CallbackQueryHandler(
        lambda u, c: button_handler(u, c, db),
        pattern=r"^(approve|reject|edit)\|"
    ))
    application.add_handler(CommandHandler("skip", skip_edit_handler))

    # ИСПРАВЛЕННАЯ РЕГИСТРАЦИЯ ОБРАБОТЧИКА ТЕКСТА
    application.add_handler(MessageHandler(
        filters.TEXT & ~filters.COMMAND & filters.ChatType.PRIVATE,
        lambda u, c: edit_text_handler(u, c, db)
    ))

    # Добавьте этот обработчик ошибок
    application.add_error_handler(error_handler)

    # --- Запуск ---
    application.run_polling()


if __name__ == "__main__":
    run_bot()
===== C:\Users\SK-GROUP\PycharmProjects\PythonProject\energy_news_project\bot\cli.py =====
# bot/cli.py
import os
import json
import asyncio
from bot.db import NewsDB
from bot.telegram_bot import send_to_moderation, make_news_id

DATA_DIR = "data"

async def load_and_send_news(db: NewsDB, bot):
    """
    Консольное меню для загрузки новостей и отправки их в модерацию.
    """
    while True:
        print("\nВыберите действие:")
        print("1) Загрузить новые новости из последнего файла energy_news*.json")
        print("2) Загрузить новости из выбранного файла")
        print("3) Показать количество новостей в базе")
        print("4) Очистить NEWS_DB и sent_ids.json")
        print("0) Выход")

        choice = (await asyncio.to_thread(input, "Введите пункт меню: ")).strip()

        # --- 1) Последний файл ---
        if choice == "1":
            files = [os.path.join(DATA_DIR, f) for f in os.listdir(DATA_DIR)
                     if f.startswith("energy_news") and f.endswith(".json")]
            latest_file = max(files, key=os.path.getctime) if files else None

            if not latest_file:
                print("❗ Нет файлов energy_news*.json")
                continue

            with open(latest_file, "r", encoding="utf-8") as f:
                news_list = json.load(f)
            print(f"📂 Загружено {len(news_list)} новостей из {os.path.basename(latest_file)}")

        # --- 2) Выбранный файл ---
        elif choice == "2":
            file_name = (await asyncio.to_thread(input, "Введите имя файла в папке data/: ")).strip()
            file_path = os.path.join(DATA_DIR, file_name)
            if not os.path.exists(file_path):
                print("❗ Файл не найден")
                continue
            with open(file_path, "r", encoding="utf-8") as f:
                news_list = json.load(f)
            print(f"📂 Загружено {len(news_list)} новостей из {file_name}")

        # --- 3) Количество новостей ---
        elif choice == "3":
            print(f"📊 В базе {len(db.news_db)} новостей.")
            continue

        # --- 4) Очистка базы ---
        elif choice == "4":
            db.news_db.clear()
            db.sent_ids.clear()
            db.save_db()
            db.save_sent_ids()
            print("🗑️ NEWS_DB и sent_ids.json очищены.")
            continue

        # --- 0) Выход ---
        elif choice == "0":
            print("👋 Выход из режима загрузки новостей.")
            break
        else:
            print("❌ Неверный выбор. Попробуйте снова.")
            continue

        # --- Отправка новостей в модерацию ---
        count = 0
        for i, item in enumerate(news_list):
            if not all(k in item for k in ["title", "source", "date", "url", "preview", "full_text"]):
                print(f"⚠️ Пропущена новость #{i} — не хватает ключей")
                continue

            item_id = make_news_id(item, i)
            if item_id in db.sent_ids:
                print(f"⏩ Новость {item_id} уже была отправлена ранее, пропускаем")
                continue

            item["id"] = item_id
            print(f"📨 Отправляем новость {item_id} в канал модерации...")
            await send_to_moderation(bot, item, db)
            count += 1

        print(f"✅ Всего отправлено в модерацию: {count} новых новостей.")
===== C:\Users\SK-GROUP\PycharmProjects\PythonProject\energy_news_project\bot\db.py =====
# bot/db.py
import json
import os

class NewsDB:
    def __init__(self, db_file="data/news_db.json", sent_ids_file="data/sent_ids.json"):
        self.db_file = db_file
        self.sent_ids_file = sent_ids_file
        os.makedirs(os.path.dirname(self.db_file), exist_ok=True)
        os.makedirs(os.path.dirname(self.sent_ids_file), exist_ok=True)
        self.news_db = {}   # {news_id: {...}}
        self.sent_ids = set()
        self.load_db()
        self.load_sent_ids()

    def load_db(self):
        if os.path.exists(self.db_file):
            with open(self.db_file, "r", encoding="utf-8") as f:
                self.news_db = json.load(f)

    def save_db(self):
        with open(self.db_file, "w", encoding="utf-8") as f:
            json.dump(self.news_db, f, ensure_ascii=False)

    def load_sent_ids(self):
        if os.path.exists(self.sent_ids_file):
            with open(self.sent_ids_file, "r", encoding="utf-8") as f:
                self.sent_ids = set(json.load(f))

    def save_sent_ids(self):
        with open(self.sent_ids_file, "w", encoding="utf-8") as f:
            json.dump(list(self.sent_ids), f, ensure_ascii=False)

    # --- Утилиты для работы с БД ---
    def add_news(self, news_id, news_data, message_id, channel_id):
        self.news_db[news_id] = {
            "news_data": news_data,
            "message_id": message_id,
            "channel_id": channel_id
        }
        self.sent_ids.add(news_id)
        self.save_db()
        self.save_sent_ids()

    def get_news(self, news_id):
        return self.news_db.get(news_id)

    def delete_news(self, news_id):
        if news_id in self.news_db:
            del self.news_db[news_id]
            self.sent_ids.discard(news_id)
            self.save_db()
            self.save_sent_ids()
===== C:\Users\SK-GROUP\PycharmProjects\PythonProject\energy_news_project\bot\formatters.py =====
# bot/formatters.py
import re
import html

def safe_clean_text(text: str) -> str:
    """
    Очищает текст от HTML-тегов, лишних пробелов и спецсимволов.
    """
    if not text:
        return ""
    # Удаляем HTML теги
    text = re.sub(r"<[^>]+>", "", text)
    # Раскодируем HTML сущности
    text = html.unescape(text)
    # Заменяем множественные пробелы на один
    text = re.sub(r"\s+", " ", text).strip()
    return text


def format_news_for_publication(news_item: dict, max_length: int = 3800) -> str:
    """
    Форматирует новость для публикации в канал Telegram.
    """
    title = safe_clean_text(news_item.get("title", "Без заголовка"))
    text = safe_clean_text(news_item.get("full_text", ""))
    source = safe_clean_text(news_item.get("source", "Источник не указан"))
    url = news_item.get("url", "")

    if len(text) > max_length:
        text = text[:max_length] + "... [обрезано]"

    return f"🔥 {title}\n\n{text}\n\nИсточник: {source}\nОригинал: {url}"
===== C:\Users\SK-GROUP\PycharmProjects\PythonProject\energy_news_project\bot\telegram_bot.py =====
# bot/telegram_bot.py
import asyncio
import hashlib
import logging
from telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.error import TelegramError, RetryAfter
from bot.formatters import format_news_for_publication
from bot.db import NewsDB

logger = logging.getLogger(__name__)

# --- Константы каналов ---
MODERATION_CHANNEL = "-1002996332660"
PUBLISH_CHANNEL = "-1003006895565"

# --- Утилиты ---
def make_news_id(item, index=0):
    """
    Генерирует уникальный ID новости на основе URL, заголовка или превью.
    """
    key = (item.get("url") or "").strip()
    if not key:
        key = f"{item.get('title','')}-{item.get('date','')}".strip()
    if not key:
        key = item.get("preview", "")[:120]
    return hashlib.sha256(key.encode("utf-8")).hexdigest()[:16]


async def send_with_delay(bot: Bot, chat_id: str, text: str, reply_markup=None,
                          pause: float = 1.5, max_retries: int = 5):
    """
    Отправка сообщения с задержкой и повторной попыткой при ошибках.
    """
    attempt = 0
    while attempt < max_retries:
        try:
            message = await bot.send_message(
                chat_id=chat_id,
                text=text,
                reply_markup=reply_markup,
                disable_web_page_preview=True,
            )
            await asyncio.sleep(pause)
            return message
        except RetryAfter as e:
            wait_time = e.retry_after
            logger.warning(f"Flood control: ждём {wait_time} сек...")
            await asyncio.sleep(wait_time)
            attempt += 1
        except TelegramError as e:
            logger.error(f"Ошибка Telegram при отправке: {e}")
            return None
        except Exception as e:
            logger.error(f"Неизвестная ошибка при отправке: {e}")
            return None
    logger.error("Не удалось отправить сообщение после всех попыток.")
    return None


async def send_to_moderation(bot: Bot, news_item: dict, db: NewsDB):
    """
    Отправка новости в канал модерации с кнопками approve/reject/edit.
    """
    news_id = news_item["id"]
    text = (
        f"📰 <b>{news_item['title']}</b>\n\n"
        f"{news_item['preview']}\n\n"
        f"<i>Источник: {news_item['source']} ({news_item['date']})</i>\n"
        f"{news_item['url']}"
    )
    keyboard = [
        [
            InlineKeyboardButton("✅ Опубликовать", callback_data=f"approve|{news_id}"),
            InlineKeyboardButton("❌ Отклонить", callback_data=f"reject|{news_id}"),
            InlineKeyboardButton("✏️ Редактировать", callback_data=f"edit|{news_id}")
        ]
    ]

    logger.info(f"Отправка новости {news_id} в канал модерации...")
    message = await send_with_delay(
        bot,
        MODERATION_CHANNEL,
        text,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

    if message:
        db.add_news(news_id, news_item, message.message_id, MODERATION_CHANNEL)
        logger.info(f"Новость {news_id} отправлена в модерацию (message_id={message.message_id})")
    else:
        logger.error(f"Не удалось отправить новость {news_id} в канал модерации.")
===== C:\Users\SK-GROUP\PycharmProjects\PythonProject\energy_news_project\bot\telegram_handlers.py =====
import asyncio
import logging
from telegram import Update
from telegram.ext import ContextTypes
from bot.telegram_bot import PUBLISH_CHANNEL
from bot.formatters import format_news_for_publication, safe_clean_text
from bot.db import NewsDB

logger = logging.getLogger(__name__)


async def split_and_send_text(bot, chat_id, text, max_length=4000):
    """
    Разбивает длинный текст на части и отправляет несколько сообщений.
    """
    if len(text) <= max_length:
        try:
            await bot.send_message(chat_id=chat_id, text=text)
            await asyncio.sleep(0.5)  # Небольшая задержка
        except Exception as e:
            logger.error(f"Ошибка отправки сообщения: {e}")
        return

    # Разбиваем по предложениям для лучшей читаемости
    sentences = text.split('. ')
    current_chunk = ""

    for sentence in sentences:
        if len(current_chunk + sentence + '. ') <= max_length:
            current_chunk += sentence + '. '
        else:
            if current_chunk:
                try:
                    await bot.send_message(chat_id=chat_id, text=current_chunk.strip())
                    await asyncio.sleep(0.5)  # Задержка между сообщениями
                except Exception as e:
                    logger.error(f"Ошибка отправки части сообщения: {e}")
                current_chunk = sentence + '. '
            else:
                # Если предложение слишком длинное, разбиваем принудительно
                while len(sentence) > max_length:
                    try:
                        await bot.send_message(chat_id=chat_id, text=sentence[:max_length])
                        await asyncio.sleep(0.5)
                    except Exception as e:
                        logger.error(f"Ошибка отправки длинного сообщения: {e}")
                    sentence = sentence[max_length:]
                current_chunk = sentence + '. ' if sentence else ""

    # Отправляем остаток
    if current_chunk:
        try:
            await bot.send_message(chat_id=chat_id, text=current_chunk.strip())
            await asyncio.sleep(0.5)
        except Exception as e:
            logger.error(f"Ошибка отправки остатка сообщения: {e}")


# --- Обработчик нажатий кнопок ---
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE, db: NewsDB):
    query = update.callback_query
    await query.answer()
    try:
        action, news_id = query.data.split("|", 1)
        logger.info(f"Обрабатываем действие: {action} для новости {news_id}")

        data_entry = db.get_news(news_id)
        if not data_entry:
            await query.edit_message_text("⚠️ Запись не найдена.")
            return

        channel_id = data_entry["channel_id"]
        message_id = data_entry["message_id"]
        news_item = data_entry["news_data"]

        if action == "approve":
            news_item = data_entry["news_data"]
            publication_text = format_news_for_publication(news_item)

            # Проверяем, была ли новость отредактирована
            edit_status = " (ОТРЕДАКТИРОВАНО)" if news_item.get("edited", False) else ""

            # Публикуем в канал
            logger.info(f"Начинаем публикацию в канал {PUBLISH_CHANNEL}")
            await context.bot.send_message(
                chat_id=PUBLISH_CHANNEL,
                text=publication_text,
                disable_web_page_preview=True,
            )
            logger.info(f"Успешно опубликовано в канал")

            # Пытаемся обновить сообщение в модерации
            try:
                # Очищаем текст для безопасного отображения
                clean_title = safe_clean_text(news_item.get("title", ""))
                clean_preview = safe_clean_text(news_item.get("preview", ""))
                clean_source = safe_clean_text(news_item.get("source", ""))
                clean_date = safe_clean_text(news_item.get("date", ""))

                original_message = (
                    f"📰 {clean_title}\n\n"
                    f"{clean_preview}\n\n"
                    f"Источник: {clean_source} ({clean_date})\n"
                    f"{news_item.get('url', '')}"
                )

                await context.bot.edit_message_text(
                    chat_id=channel_id,
                    message_id=message_id,
                    text=f"✅ ОПУБЛИКОВАНО{edit_status}\n\n{original_message}",
                    reply_markup=None,
                )
            except Exception as edit_error:
                logger.warning(f"Не удалось обновить сообщение в модерации: {edit_error}")
                # Если не можем отредактировать, отправляем новое сообщение
                await context.bot.send_message(
                    chat_id=channel_id,
                    text=f"✅ Новость {news_id} опубликована{edit_status.lower()}"
                )

            logger.info(f"Новость {news_id} опубликована{edit_status.lower()}.")

        elif action == "reject":
            await context.bot.edit_message_text(
                chat_id=channel_id,
                message_id=message_id,
                text=f"❌ ОТКЛОНЕНО\n\n{query.message.text}",
                reply_markup=None,
            )
            logger.info(f"Новость {news_id} отклонена.")

        elif action == "edit":
            # Показываем полный текст статьи в нескольких сообщениях
            full_text = news_item.get("full_text", "")
            if full_text:
                await query.message.reply_text(
                    f"📝 Текущий полный текст новости (ID: {news_id}):"
                )
                await split_and_send_text(context.bot, query.message.chat_id, full_text)
            else:
                await query.message.reply_text("⚠️ Полный текст новости отсутствует.")

            await query.message.reply_text(
                "✏️ Отправьте исправленный текст новости.\n"
                "Чтобы оставить как есть — отправьте /skip"
            )
            context.user_data["editing_news_id"] = news_id

    except Exception as e:
        logger.error(f"Ошибка обработки callback: {e}")
        await query.edit_message_text(f"⚠️ Ошибка: {e}")


# --- Обработчик редактирования текста ---
async def edit_text_handler(update: Update, context: ContextTypes.DEFAULT_TYPE, db: NewsDB):
    logger.info(f"edit_text_handler вызван с текстом: {update.message.text[:100]}")
    logger.info(f"user_data: {context.user_data}")

    # Проверяем, что user_data не None
    if context.user_data is None:
        logger.warning("User data is None, skipping edit handling")
        return

    news_id = context.user_data.get("editing_news_id")
    logger.info(f"editing_news_id: {news_id}")

    if not news_id:
        logger.info("Нет активного редактирования, пропускаем")
        return

    if update.message.text == "/skip":
        await update.message.reply_text("Редактирование пропущено.")
        context.user_data["editing_news_id"] = None
        return

    # Обновляем текст новости
    db.news_db[news_id]["news_data"]["full_text"] = update.message.text
    # Помечаем, что новость была отредактирована
    db.news_db[news_id]["news_data"]["edited"] = True
    db.save_db()

    # Отладочная информация
    logger.info(f"Текст новости {news_id} обновлен на: {update.message.text[:100]}")

    await update.message.reply_text(
        "✅ Текст новости обновлён! Теперь нажмите кнопку 'Опубликовать' для публикации отредактированной версии.")

    context.user_data["editing_news_id"] = None


# --- Обработчик команды /skip ---
async def skip_edit_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Проверяем, что user_data не None
    if context.user_data is None:
        logger.warning("User data is None, skipping skip command")
        return

    news_id = context.user_data.get("editing_news_id")
    if news_id:
        context.user_data["editing_news_id"] = None
        await update.message.reply_text("Редактирование пропущено.")
===== C:\Users\SK-GROUP\PycharmProjects\PythonProject\energy_news_project\bot\__init__.py =====
# Пакет для Telegram-бота модерации и публикации
