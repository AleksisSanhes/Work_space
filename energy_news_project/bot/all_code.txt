===== C:\Users\SK-GROUP\PycharmProjects\PythonProject\energy_news_project\bot\db.py =====
import json
import os

SENT_IDS_FILE = "data/sent_ids.json"
NEWS_DB_FILE = "data/news_db.json"

NEWS_DB = {}

def load_sent_ids() -> set:
    if os.path.exists(SENT_IDS_FILE):
        with open(SENT_IDS_FILE, "r", encoding="utf-8") as f:
            return set(json.load(f))
    return set()

def save_sent_ids(sent_ids: set):
    with open(SENT_IDS_FILE, "w", encoding="utf-8") as f:
        json.dump(list(sent_ids), f, ensure_ascii=False)

def load_news_db():
    global NEWS_DB
    if os.path.exists(NEWS_DB_FILE):
        with open(NEWS_DB_FILE, "r", encoding="utf-8") as f:
            NEWS_DB = json.load(f)

def save_news_db():
    with open(NEWS_DB_FILE, "w", encoding="utf-8") as f:
        json.dump(NEWS_DB, f, ensure_ascii=False)
===== C:\Users\SK-GROUP\PycharmProjects\PythonProject\energy_news_project\bot\formatters.py =====
import re
import html

def safe_clean_text(text: str) -> str:
    if not text:
        return ""
    text = re.sub(r"<[^>]+>", "", text)
    text = html.unescape(text)
    text = re.sub(r"\s+", " ", text).strip()
    return text

def format_news_for_publication(news_item: dict) -> str:
    title = safe_clean_text(news_item.get("title", "Без заголовка"))
    text = safe_clean_text(news_item.get("full_text", ""))
    source = safe_clean_text(news_item.get("source", "Источник не указан"))
    url = news_item.get("url", "")

    if len(text) > 3800:
        text = text[:3800] + "... [обрезано]"

    return f"🔥 {title}\n\n{text}\n\nИсточник: {source}\nОригинал: {url}"
===== C:\Users\SK-GROUP\PycharmProjects\PythonProject\energy_news_project\bot\moderation_bot.py =====
import os
import json
import asyncio
import html
import re
import hashlib
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, Bot
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
import re
import asyncio
import logging
from telegram.error import TelegramError, RetryAfter
from telegram.ext import MessageHandler, filters

logger = logging.getLogger(__name__)


TOKEN = "8217915867:AAFLPnQmnxhHmjloF4Ct3HhR9jjRjVYV6C8"
MODERATION_CHANNEL = "-1002996332660"
PUBLISH_CHANNEL = "-1003006895565"

DATA_DIR = "data"
os.makedirs(DATA_DIR, exist_ok=True)
SENT_IDS_FILE = os.path.join(DATA_DIR, "sent_ids.json")
NEWS_DB_FILE = os.path.join(DATA_DIR, "news_db.json")

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

NEWS_DB = {}  # {id: {... данные ...}}

# ---------- Утилиты ----------
def make_news_id(item, index=0):
    key = (item.get("url") or "").strip()
    if not key:
        key = f"{item.get('title','')}-{item.get('date','')}".strip()
    if not key:
        key = item.get("preview", "")[:120]
    return hashlib.sha256(key.encode("utf-8")).hexdigest()[:16]


def safe_clean_text(text: str) -> str:
    if not text:
        return ""
    text = re.sub(r"<[^>]+>", "", text)
    text = html.unescape(text)
    text = re.sub(r"\s+", " ", text).strip()
    return text


# ---------- Работа с файлами ----------
def load_sent_ids() -> set:
    if os.path.exists(SENT_IDS_FILE):
        with open(SENT_IDS_FILE, "r", encoding="utf-8") as f:
            return set(json.load(f))
    return set()


def save_sent_ids(sent_ids: set):
    os.makedirs(os.path.dirname(SENT_IDS_FILE), exist_ok=True)
    with open(SENT_IDS_FILE, "w", encoding="utf-8") as f:
        json.dump(list(sent_ids), f, ensure_ascii=False)


def load_news_db():
    global NEWS_DB
    if os.path.exists(NEWS_DB_FILE):
        with open(NEWS_DB_FILE, "r", encoding="utf-8") as f:
            NEWS_DB = json.load(f)
        logger.info(f"Загружено NEWS_DB ({len(NEWS_DB)} записей).")


def save_news_db():
    os.makedirs(os.path.dirname(NEWS_DB_FILE), exist_ok=True)
    with open(NEWS_DB_FILE, "w", encoding="utf-8") as f:
        json.dump(NEWS_DB, f, ensure_ascii=False)


# ---------- Отправка с задержкой ----------
async def send_with_delay(bot, chat_id, text, reply_markup=None, pause: float = 1.5, max_retries: int = 5):
    attempt = 0
    while attempt < max_retries:
        try:
            message = await bot.send_message(
                chat_id=chat_id,
                text=text,
                reply_markup=reply_markup,
                disable_web_page_preview=True,
            )
            print(f"✅ Сообщение отправлено в {chat_id}")
            await asyncio.sleep(pause)
            return message
        except RetryAfter as e:
            wait_time = e.retry_after
            print(f"⚠️ Flood control: ждём {wait_time} сек...")
            await asyncio.sleep(wait_time)
            attempt += 1
        except TelegramError as e:
            print(f"❌ Ошибка Telegram при отправке: {e}")
            return None
        except Exception as e:
            print(f"❌ Неизвестная ошибка: {e}")
            return None
    print("❌ Не удалось отправить сообщение после всех попыток.")
    return None

# ---------- Telegram Handlers ----------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Бот запущен.")


async def test_publish_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        await context.bot.send_message(chat_id=PUBLISH_CHANNEL, text="🔔 Тестовая публикация")
        await update.message.reply_text("Отправлено (если бот имеет доступ к каналу).")
    except Exception as e:
        await update.message.reply_text(f"⚠️ Ошибка при публикации: {e}")


async def send_to_moderation(bot: Bot, news_item: dict, sent_ids: set):
    """Отправка новости в канал модерации"""
    news_id = news_item["id"]

    # Текст для модерации
    text = (
        f"📰 <b>{news_item['title']}</b>\n\n"
        f"{news_item['preview']}\n\n"
        f"<i>Источник: {news_item['source']} ({news_item['date']})</i>\n"
        f"{news_item['url']}"
    )

    # Кнопки
    keyboard = [
        [
            InlineKeyboardButton("✅ Опубликовать", callback_data=f"approve|{news_id}"),
            InlineKeyboardButton("❌ Отклонить", callback_data=f"reject|{news_id}"),
            InlineKeyboardButton("✏️ Редактировать", callback_data=f"edit|{news_id}")
        ]
    ]

    print(f"📨 Пытаюсь отправить новость {news_id} в {MODERATION_CHANNEL} ...")

    # Отправляем в канал
    message = await send_with_delay(
        bot,
        MODERATION_CHANNEL,
        text,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

    if not message:
        print(f"❌ Не удалось отправить новость {news_id} в канал модерации.")
        return

    print(f"✅ Новость {news_id} отправлена в канал модерации (message_id={message.message_id})")

    # Сохраняем в БД
    NEWS_DB[news_id] = {
        "message_id": message.message_id,
        "news_data": news_item,
        "channel_id": MODERATION_CHANNEL
    }
    save_news_db()

    # Добавляем в список отправленных
    sent_ids.add(news_id)
    save_sent_ids(sent_ids)


def format_news_for_publication(news_item: dict) -> str:
    title = safe_clean_text(news_item.get("title", "Без заголовка"))
    text = safe_clean_text(news_item.get("full_text", ""))
    source = safe_clean_text(news_item.get("source", "Источник не указан"))
    url = news_item.get("url", "")

    if len(text) > 3800:
        text = text[:3800] + "... [обрезано]"

    return f"🔥 {title}\n\n{text}\n\nИсточник: {source}\nОригинал: {url}"


async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    try:
        action, news_id = query.data.split("|", 1)
        data_entry = NEWS_DB.get(news_id)
        if not data_entry:
            await query.edit_message_text("⚠️ Запись не найдена.")
            return

        channel_id = data_entry["channel_id"]
        message_id = data_entry["message_id"]
        news_item = data_entry["news_data"]

        if action == "approve":
            publication_text = format_news_for_publication(news_item)
            await context.bot.send_message(
                chat_id=PUBLISH_CHANNEL,
                text=publication_text,
                disable_web_page_preview=True,
            )
            await context.bot.edit_message_text(
                chat_id=channel_id,
                message_id=message_id,
                text=f"✅ ОПУБЛИКОВАНО\n\n{query.message.text}",
                reply_markup=None,
            )
            logger.info(f"Новость {news_id} опубликована.")

        elif action == "reject":
            await context.bot.edit_message_text(
                chat_id=channel_id,
                message_id=message_id,
                text=f"❌ ОТКЛОНЕНО\n\n{query.message.text}",
                reply_markup=None,
            )
            logger.info(f"Новость {news_id} отклонена.")

        elif action == "edit":
            await query.message.reply_text(
                "✏️ Отправьте исправленный текст новости.\n"
                "Чтобы оставить как есть — отправьте /skip",
                reply_markup=None
            )
            context.user_data["editing_news_id"] = news_id

        save_news_db()

    except Exception as e:
        logger.error(f"Ошибка обработки callback: {e}")
        await query.edit_message_text(f"⚠️ Ошибка: {e}")

async def edit_text_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    news_id = context.user_data.get("editing_news_id")
    if not news_id:
        return  # Нет новости для редактирования

    if update.message.text == "/skip":
        await update.message.reply_text("Редактирование пропущено.")
    else:
        # Сохраняем новый текст
        NEWS_DB[news_id]["news_data"]["full_text"] = update.message.text
        await update.message.reply_text("Текст новости обновлён.")

    # Очистка состояния редактирования
    context.user_data["editing_news_id"] = None
    save_news_db()


async def skip_edit_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    news_id = context.user_data.get("editing_news_id")
    if news_id:
        context.user_data["editing_news_id"] = None
        await update.message.reply_text("Редактирование пропущено.")


# ---------- Основные функции работы ----------
async def load_and_send_news(bot: Bot):
    """Консольное меню: загрузка и отправка новостей + режим слушания модерации"""
    load_news_db()
    sent_ids = load_sent_ids()

    while True:
        print("\nВыберите действие:")
        print("1) Загрузить новые новости из последнего файла energy_news*.json")
        print("2) Загрузить новости из выбранного файла")
        print("3) Показать количество новостей в базе")
        print("4) Очистить канал Публикации")
        print("5) Очистить канал Модерации")
        print("6) Включить режим слушания модерации")
        print("7) Очистить NEWS_DB и sent_ids.json")
        print("0) Выход")

        choice = (await asyncio.to_thread(input, "Введите пункт меню: ")).strip()

        # --- 1) Загрузить новости из последнего файла ---
        if choice == "1":
            files = [os.path.join(DATA_DIR, f) for f in os.listdir(DATA_DIR)
                     if f.startswith("energy_news") and f.endswith(".json")]
            latest_file = max(files, key=os.path.getctime) if files else None

            if not latest_file:
                print("❗ Нет файлов energy_news*.json")
                continue

            with open(latest_file, "r", encoding="utf-8") as f:
                news_list = json.load(f)
            print(f"📂 Загружено {len(news_list)} новостей из {os.path.basename(latest_file)}")

            count = 0
            for i, item in enumerate(news_list):
                if not all(k in item for k in ["title", "source", "date", "url", "preview", "full_text"]):
                    print(f"⚠️ Пропущена новость #{i} — не хватает ключей")
                    continue

                item_id = make_news_id(item, i)
                if item_id in sent_ids:
                    print(f"⏩ Новость {item_id} уже была отправлена ранее, пропускаем")
                    continue

                item["id"] = item_id
                print(f"📨 Отправляем новость {item_id} в канал модерации...")
                await send_to_moderation(bot, item, sent_ids)
                count += 1

            print(f"✅ Всего отправлено в модерацию: {count} новых новостей.")

        # --- 2) Загрузить новости из выбранного файла ---
        elif choice == "2":
            file_name = (await asyncio.to_thread(input, "Введите имя файла в папке data/: ")).strip()
            file_path = os.path.join(DATA_DIR, file_name)
            if not os.path.exists(file_path):
                print("❗ Файл не найден")
                continue

            with open(file_path, "r", encoding="utf-8") as f:
                news_list = json.load(f)
            print(f"📂 Загружено {len(news_list)} новостей из {file_name}")

            count = 0
            for i, item in enumerate(news_list):
                if not all(k in item for k in ["title", "source", "date", "url", "preview", "full_text"]):
                    continue

                item_id = make_news_id(item, i)
                if item_id in sent_ids:
                    continue

                item["id"] = item_id
                await send_to_moderation(bot, item, sent_ids)
                count += 1

            print(f"✅ Всего отправлено в модерацию: {count} новых новостей.")

        # --- 3) Показать количество новостей в базе ---
        elif choice == "3":
            print(f"📊 В базе {len(NEWS_DB)} новостей.")

        # --- 4) Очистить канал Публикации ---
        elif choice == "4":
            for news_id, entry in list(NEWS_DB.items()):
                if entry["channel_id"] == PUBLISH_CHANNEL and entry["message_id"]:
                    try:
                        await bot.delete_message(PUBLISH_CHANNEL, entry["message_id"])
                        del NEWS_DB[news_id]
                    except Exception as e:
                        print(f"Ошибка удаления {entry['message_id']}: {e}")
            save_news_db()
            print("🗑️ Канал Публикации очищен.")

        # --- 5) Очистить канал Модерации ---
        elif choice == "5":
            for news_id, entry in list(NEWS_DB.items()):
                if entry["channel_id"] == MODERATION_CHANNEL and entry["message_id"]:
                    try:
                        await bot.delete_message(MODERATION_CHANNEL, entry["message_id"])
                        del NEWS_DB[news_id]
                    except Exception as e:
                        print(f"Ошибка удаления {entry['message_id']}: {e}")
            save_news_db()
            print("🗑️ Канал Модерации очищен.")

        # --- 6) Включить режим слушания модерации ---
        elif choice == "6":
            print("👂 Режим слушания модерации включен. Бот теперь реагирует на кнопки approve/reject/edit...")
            # Здесь просто выходим из цикла, бот уже слушает кнопки через CallbackQueryHandler
            break

        # --- 7) Очистить базу и sent_ids.json ---
        elif choice == "7":
            NEWS_DB.clear()
            save_news_db()
            with open(SENT_IDS_FILE, "w", encoding="utf-8") as f:
                json.dump([], f)
            print("🗑️ NEWS_DB и sent_ids.json очищены.")

        # --- 0) Выход ---
        elif choice == "0":
            print("👋 Выход из режима загрузки новостей.")
            break

        else:
            print("❌ Неверный выбор. Попробуйте снова.")


# ---------- Post init ----------
async def post_init(app: Application):
    try:
        await app.bot.delete_webhook(drop_pending_updates=True)
    except Exception as e:
        logger.warning(f"Не удалось удалить webhook: {e}")

    load_news_db()

    # 🚀 Меню запускаем отдельным таском, и оно вызывается по кругу
    async def menu_loop():
        while True:
            await load_and_send_news(app.bot)

    asyncio.create_task(menu_loop())


# ---------- Запуск бота ----------
def run_bot():
    application = Application.builder().token(TOKEN).post_init(post_init).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("testpublish", test_publish_command))
    application.add_handler(CallbackQueryHandler(button_handler, pattern=r"^(approve|reject|edit)\|"))
    application.add_handler(CommandHandler("skip", skip_edit_handler))
    application.add_handler(MessageHandler(
    filters.TEXT & ~filters.COMMAND & filters.ChatType.PRIVATE,
    lambda u, c: edit_text_handler(u, c, db)
))
    application.run_polling()
===== C:\Users\SK-GROUP\PycharmProjects\PythonProject\energy_news_project\bot\__init__.py =====
# Пакет для Telegram-бота модерации и публикации
